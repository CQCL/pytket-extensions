pytket-quantinuum
==================================

.. image:: CQCLogo.png
   :width: 120px
   :align: right

``pytket-quantinuum`` is an extension to ``pytket`` that allows ``pytket`` circuits to
be executed on Quantinuum's quantum devices.

``pytket-quantinuum`` is available for Python 3.8, 3.9 and 3.10, on Linux, MacOS
and Windows. To install, run:

``pip install pytket-quantinuum``


.. note::   Requires a `Quantinuum <https://www.quantinuum.com/>`_ account.
            Use ``QuantinuumBackend.login()`` to log in using your email and password.

**Devices**

* ``H1-1``, ``H1-2``: Quantum Computers, submit specifically to ``H1-1`` or ``H1-2`` by using the device name
* ``H1-1E``, ``H1-2E``: Device-specific Emulators of ``H1-1`` and ``H1-2``. These emulators run remotely on servers and require credentials.
* ``H1-1SC``, ``H1-2SC``: Device-specific Syntax Checkers, check compilation of a quantum circuit against device-specific instructions, returns completed if syntax is correct along with the H-Series Quantum Credits (HQCs), returns failed if the syntax is incorrect along with the error.
* ``H1``: Submit to Quantinuum System Model ``H1`` machines, job is run on ``H1-1`` or ``H1-2`` based on soonest available device.

The H-series devices and emulators produce shots based results and therefore require measurements. The emulators use noise models based on the real devices. 

**Job Statuses**

When using the Quantinuum ``Backend`` to run circuits there are several possible circuit statuses.

* queued - The job has been queued but has not yet been run.
* running - circuit is currently being run on the device/emulator.
* completed - the job has finished.
* failed - job has failed.
* cancelling - the job is in the process of being cancelled.
* cancelled - the job has been cancelled.

**Web portal:**
https://um.qapi.honeywell.com/user

**Default Compilation**

Every ``Backend`` in pytket has its own ``default_compilation_pass`` method. 
This method applies a sequence of optimisations to a circuit depending on the value of an ``optimisation_level`` parameter. 
This default compilation will ensure that the circuit meets all the constraints required to run on the ``Backend``. 
The passes applied by different levels of optimisation are specified in the table below.


.. list-table:: **Default compilation pass for the Quantinuum Backend**
   :widths: 25 25 25
   :header-rows: 1

   * - optimisation_level = 0
     - optimisation_level = 1 [1]
     - optimisation_level = 2
   * - `DecomposeBoxes <https://cqcl.github.io/tket/pytket/api/passes.html#pytket.passes.DecomposeBoxes>`_
     - `DecomposeBoxes <https://cqcl.github.io/tket/pytket/api/passes.html#pytket.passes.DecomposeBoxes>`_
     - `DecomposeBoxes <https://cqcl.github.io/tket/pytket/api/passes.html#pytket.passes.DecomposeBoxes>`_
   * - self.rebase_pass [2]
     - `SynthesiseTket <https://cqcl.github.io/tket/pytket/api/passes.html#pytket.passes.SynthesiseTket>`_
     - `FullPeepholeOptimise <https://cqcl.github.io/tket/pytket/api/passes.html#pytket.passes.FullPeepholeOptimise>`_
   * -
     - self.rebase_pass [2]
     - `SynthesiseTket <https://cqcl.github.io/tket/pytket/api/passes.html#pytket.passes.SynthesiseTket>`_
   * -
     - `auto_squash_pass [3] <https://cqcl.github.io/tket/pytket/api/passes.html#pytket.passes.auto_rebase.auto_squash_pass>`_
     - self.rebase_pass [2]
   * -
     - `SimplifyInitial [4] <https://cqcl.github.io/tket/pytket/api/passes.html#pytket.passes.SimplifyInitial>`_
     - `auto_squash_pass [3] <https://cqcl.github.io/tket/pytket/api/passes.html#pytket.passes.auto_rebase.auto_squash_pass>`_
   * -
     -
     - `SimplifyInitial [4] <https://cqcl.github.io/tket/pytket/api/passes.html#pytket.passes.SimplifyInitial>`_

* [1] If no value is specified then ``optimisation_level`` defaults to a value of 1.

* [2] ``self.rebase_pass`` is a rebase that converts the circuit to the Quantinuum native gate set {Rz, PhasedX, ZZMax, ZZPhase}.

* [3] ``auto_squash_pass`` has arguments ``auto_squash_pass({OpType.PhasedX,OpType.Rz})``

* [4] ``SimplifyInitial`` has arguments  ``SimplifyInitial(allow_classical=False, create_all_qubits=True, xcirc=xcirc)``

.. note::   If ``optimisation_level = 0`` the device constraints are solved but no additional optimisation is applied. Setting ``optimisation_level = 1`` applies some light optimisations to the circuit. More intensive optimisation is applied by level 2 at the expense of increased runtime.

**Device Predicates**

Circuits must satisfy the following predicates in order to run on the ``QuantinuumBackend``.

* `NoSymbolsPredicate  <https://cqcl.github.io/tket/pytket/api/predicates.html#pytket.predicates.NoSymbolsPredicate>`_  - Parameterised gates must have numerical parameters when the circuit is executed.
* `GateSetPredicate  <https://cqcl.github.io/tket/pytket/api/predicates.html#pytket.predicates.GateSetPredicate>`_ : To view supported Ops run ``QuantinuumBackend.backend_info.gate_set``
* `MaxNQubitsPredicate(12) <https://cqcl.github.io/tket/pytket/api/predicates.html#pytket.predicates.MaxNQubitsPredicate>`_ for ``H1-1``, ``H1-2`` and ``H1-2E``. ``MaxNQubitsPredicate(20)`` for ``H1-1E``.


**Additional Backend Capabilities**

The Quantinuum ``Backend`` has a ``cost`` method. This calculates the cost (in H-series Quantum Credits) required to execute the circuit for the specified number of shots.  

There are also ``login()`` and ``logout()`` methods. 
After the login method is called the user will be prompted for their Quantinuum username and password.

The ``process_circuits`` method for the QuantinuumBackend accepts the following additional keyword arguments.

*  ``postprocess`` : boolean flag to allow classical postprocessing.
*  ``noisy_simulation`` : boolean flag to specify whether the simulator should
   perform noisy simulation with an error model (default value is ``True``).
*  ``group`` : string identifier of a collection of jobs, can be used for usage tracking.
*  ``max_batch_cost``: maximum HQC usable by submitted batch, default is 500.
*  ``batch_id`` : first ``jobid`` of the batch to which this batch of circuits should be submitted. Job IDs can be retrieved from ResultHandle using ``backend.get_jobid(handle)``.
*  ``close_batch`` : boolean flag to close the batch after the last circuit in the job, ``default=True``.

For the Quantinuum ``Backend``, ``process_circuits`` returns a ResultHandle object containing a ``job_id`` and a postprocessing ( ``ppcirc``) circuit if there is one. The ``logout()`` method clears stored JSON web tokens and will have to sign in to access the Quantinuum API.

Every Quantinuum ``Backend`` supports mid circuit measurements.


.. toctree::
    api.rst
    changelog.rst