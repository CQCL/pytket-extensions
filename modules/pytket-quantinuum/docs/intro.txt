pytket-quantinuum
==================================

.. image:: CQCLogo.png
   :width: 120px
   :align: right

``pytket-quantinuum`` is an extension to ``pytket`` that allows ``pytket`` circuits to
be executed on Quantinuum's quantum devices.

``pytket-quantinuum`` is available for Python 3.8, 3.9 and 3.10, on Linux, MacOS
and Windows. To install, run:

::

    pip install pytket-quantinuum

.. note::   Requires a `Quantinuum <https://www.quantinuum.com/>`_ account.
            Use ``QuantinuumBackend.login()`` to log in using your email and password.

Devices
=======
The pytket-quantinuum extension allows the user to access the following quantum devices, emulators and syntax checkers. These backends can be initialised  by passing the device name as a string to the ``QuantinuumBackend`` class.

* ``H1-1``, ``H1-2``: Quantum computers, submit specifically to ``H1-1`` or ``H1-2`` by using the device name
* ``H1-1E``, ``H1-2E``: Device-specific Emulators of ``H1-1`` and ``H1-2``. These emulators run remotely on servers and require credentials.
* ``H1-1SC``, ``H1-2SC``: Device-specific syntax checkers. These check compilation of a quantum circuit against device-specific instructions, and return status "completed" if the syntax is correct (along with the H-Series Quantum Credits (HQCs)), or status "failed" if the syntax is incorrect (along with the error).
* ``H1``: Submit to Quantinuum ``H1`` machines: job is run on ``H1-1`` or ``H1-2`` based on the soonest available device.

The H-series devices and emulators produce shots-based results and therefore require measurements. It is also possible to use a stabilizer simulator by specifying ``simulator='stabilizer'``. This option may be preferable for simulating Clifford circuits.

By default the emulators use noise models based on the real devices. It is possible to perform a noiseless simulation by specifying ``noisy_simulation=False``.  

For examples demonstrating the ``QuantinuumBackend`` see the `example notebooks <https://github.com/CQCL/pytket-extensions/tree/develop/modules/pytket-quantinuum/examples>`_ .

**Web portal:**
https://um.qapi.honeywell.com/user

Default Compilation
===================

Every ``Backend`` in pytket has its own ``default_compilation_pass`` method. 
This method applies a sequence of optimisations to a circuit depending on the value of an ``optimisation_level`` parameter. 
This default compilation will ensure that the circuit meets all the constraints required to run on the ``Backend``. 
The passes applied by different levels of optimisation are specified in the table below.


.. list-table:: **Default compilation pass for the Quantinuum backends**
   :widths: 25 25 25
   :header-rows: 1

   * - optimisation_level = 0
     - optimisation_level = 1 [1]
     - optimisation_level = 2
   * - `DecomposeBoxes <https://cqcl.github.io/tket/pytket/api/passes.html#pytket.passes.DecomposeBoxes>`_
     - `DecomposeBoxes <https://cqcl.github.io/tket/pytket/api/passes.html#pytket.passes.DecomposeBoxes>`_
     - `DecomposeBoxes <https://cqcl.github.io/tket/pytket/api/passes.html#pytket.passes.DecomposeBoxes>`_
   * - self.rebase_pass [2]
     - `SynthesiseTket <https://cqcl.github.io/tket/pytket/api/passes.html#pytket.passes.SynthesiseTket>`_
     - `FullPeepholeOptimise <https://cqcl.github.io/tket/pytket/api/passes.html#pytket.passes.FullPeepholeOptimise>`_
   * -
     - self.rebase_pass [2]
     - `SynthesiseTket <https://cqcl.github.io/tket/pytket/api/passes.html#pytket.passes.SynthesiseTket>`_
   * -
     - `auto_squash_pass [3] <https://cqcl.github.io/tket/pytket/api/passes.html#pytket.passes.auto_rebase.auto_squash_pass>`_
     - self.rebase_pass [2]
   * -
     - `SimplifyInitial [4] <https://cqcl.github.io/tket/pytket/api/passes.html#pytket.passes.SimplifyInitial>`_
     - `auto_squash_pass [3] <https://cqcl.github.io/tket/pytket/api/passes.html#pytket.passes.auto_rebase.auto_squash_pass>`_
   * -
     -
     - `SimplifyInitial [4] <https://cqcl.github.io/tket/pytket/api/passes.html#pytket.passes.SimplifyInitial>`_

* [1] If no value is specified then ``optimisation_level`` defaults to a value of 1.

* [2] ``self.rebase_pass`` is a rebase that converts the circuit to the Quantinuum native gate set (e.g. {Rz, PhasedX, ZZMax, ZZPhase}).

* [3] ``auto_squash_pass`` has arguments ``auto_squash_pass({OpType.PhasedX,OpType.Rz})``

* [4] ``SimplifyInitial`` has arguments  ``SimplifyInitial(allow_classical=False, create_all_qubits=True, xcirc=xcirc)``

.. note::   If ``optimisation_level = 0`` the device constraints are solved but no additional optimisation is applied. Setting ``optimisation_level = 1`` applies some light optimisations to the circuit. More intensive optimisation is applied by level 2 at the expense of increased runtime.

Device Predicates
=================

Circuits must satisfy the following predicates in order to run on the ``QuantinuumBackend``.

* `NoSymbolsPredicate  <https://cqcl.github.io/tket/pytket/api/predicates.html#pytket.predicates.NoSymbolsPredicate>`_ : Parameterised gates must have numerical parameters when the circuit is executed.
* `GateSetPredicate  <https://cqcl.github.io/tket/pytket/api/predicates.html#pytket.predicates.GateSetPredicate>`_ : To view supported Ops run ``QuantinuumBackend.backend_info.gate_set``.
* `MaxNQubitsPredicate <https://cqcl.github.io/tket/pytket/api/predicates.html#pytket.predicates.MaxNQubitsPredicate>`_ : ``H1-1``, ``H1-1E`` and ``H1-1SC`` all support a maximum of 20 qubits. The ``H1-2``, ``H1-2E`` and ``H1-2SC`` support a maximum of 12 qubits.

Job Statuses
============

When using the Quantinuum ``Backend`` to run circuits there are several possible device statuses.

* queued - The job has been queued but has not yet been run.
* running - The circuit is currently being run on the device/emulator.
* completed - The job has finished.
* failed -  The job has failed.
* cancelling - The job is in the process of being cancelled.
* cancelled - The job has been cancelled.

The status of the device can be checked with by using the ``device_state`` method. To cancel a job simply use the ``cancel`` method.

Additional Backend Capabilities
===============================

The Quantinuum ``Backend`` has a ``cost`` method. This calculates the cost (in HQCs) required to execute the circuit for the specified number of shots.  

There are also ``login()`` and ``logout()`` methods. 
After the login method is called the user will be prompted for their Quantinuum username and password.

The ``process_circuits`` method for the QuantinuumBackend accepts the following additional keyword arguments.

*  ``postprocess`` : boolean flag to allow classical postprocessing.
*  ``noisy_simulation`` : boolean flag to specify whether the simulator should
   perform noisy simulation with an error model (default value is ``True``).
*  ``group`` : string identifier of a collection of jobs, can be used for usage tracking.
*  ``max_batch_cost``: maximum HQC usable by submitted batch, default is 500.
*  ``batch_id`` : first ``jobid`` of the batch to which this batch of circuits should be submitted. Job IDs can be retrieved from ResultHandle using ``backend.get_jobid(handle)``.
*  ``close_batch`` : boolean flag to close the batch after the last circuit in the job (default value is ``True``).

For the Quantinuum ``Backend``, ``process_circuits`` returns a ``ResultHandle`` object containing a ``job_id`` and a postprocessing ( ``ppcirc``) circuit if there is one. The ``logout()`` method clears stored JSON web tokens and the user will have to sign in again to access the Quantinuum API.

Every Quantinuum ``Backend`` supports mid-circuit measurements.


.. toctree::
    api.rst
    changelog.rst